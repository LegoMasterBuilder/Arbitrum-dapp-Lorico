import {
  redundantScriptTypes
} from "./chunk-6HLMU37T.js";
import {
  isEventHandler,
  optionalImport
} from "./chunk-DLA6KCZJ.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/minifyJs.mjs
async function minifyJs(tree, options, terserOptions) {
  const terser = await optionalImport("terser");
  if (!terser) return tree;
  let promises = [];
  tree.walk((node) => {
    const nodeAttrs = node.attrs || {};
    if ("integrity" in nodeAttrs) {
      return node;
    }
    if (node.tag && node.tag === "script") {
      const mimeType = nodeAttrs.type || "text/javascript";
      if (redundantScriptTypes.has(mimeType) || mimeType === "module") {
        promises.push(processScriptNode(node, terserOptions, terser));
      }
    }
    if (node.attrs) {
      promises = promises.concat(processNodeWithOnAttrs(node, terserOptions, terser));
    }
    return node;
  });
  return Promise.all(promises).then(() => tree);
}
function stripCdata(js) {
  const leftStrippedJs = js.replace(/\/\/\s*<!\[CDATA\[/, "").replace(/\/\*\s*<!\[CDATA\[\s*\*\//, "");
  if (leftStrippedJs === js) {
    return js;
  }
  const strippedJs = leftStrippedJs.replace(/\/\/\s*\]\]>/, "").replace(/\/\*\s*\]\]>\s*\*\//, "");
  return leftStrippedJs === strippedJs ? js : strippedJs;
}
function processScriptNode(scriptNode, terserOptions, terser) {
  let js = (scriptNode.content || []).join("").trim();
  if (!js) {
    return scriptNode;
  }
  let isCdataWrapped = false;
  if (js.includes("CDATA")) {
    const strippedJs = stripCdata(js);
    isCdataWrapped = js !== strippedJs;
    js = strippedJs;
  }
  return terser.minify(js, terserOptions).then((result) => {
    if (result.error) {
      throw new Error(result.error);
    }
    if (result.code === void 0) {
      return;
    }
    let content = result.code;
    if (isCdataWrapped) {
      content = "/*<![CDATA[*/" + content + "/*]]>*/";
    }
    scriptNode.content = [content];
  });
}
function processNodeWithOnAttrs(node, terserOptions, terser) {
  const jsWrapperStart = "a=function(){";
  const jsWrapperEnd = "};a();";
  const promises = [];
  for (const attrName of Object.keys(node.attrs || {})) {
    if (!isEventHandler(attrName)) {
      continue;
    }
    let wrappedJs = jsWrapperStart + node.attrs[attrName] + jsWrapperEnd;
    let promise = terser.minify(wrappedJs, terserOptions).then(({ code }) => {
      let minifiedJs = code.substring(
        jsWrapperStart.length,
        code.length - jsWrapperEnd.length
      );
      node.attrs[attrName] = minifiedJs;
    });
    promises.push(promise);
  }
  return promises;
}
export {
  minifyJs as default
};
//# sourceMappingURL=minifyJs-SPKX7XWM.js.map
