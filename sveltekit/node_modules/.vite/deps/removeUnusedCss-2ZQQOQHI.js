import {
  extractCssFromStyleNode,
  isStyleNode,
  optionalImport
} from "./chunk-DLA6KCZJ.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/removeUnusedCss.mjs
var uncssOptions = {
  ignoreSheets: [/\s*/],
  stylesheets: []
};
function processStyleNodeUnCSS(html, styleNode, uncssOptions2, uncss) {
  const css = extractCssFromStyleNode(styleNode);
  return runUncss(html, css, uncssOptions2, uncss).then((css2) => {
    if (css2.trim().length === 0) {
      styleNode.tag = false;
      styleNode.content = [];
      return;
    }
    styleNode.content = [css2];
  });
}
function runUncss(html, css, userOptions, uncss) {
  if (typeof userOptions !== "object") {
    userOptions = {};
  }
  const options = { ...userOptions, ...uncssOptions };
  return new Promise((resolve, reject) => {
    options.raw = css;
    uncss(html, options, (error, output) => {
      if (error) {
        reject(error);
        return;
      }
      resolve(output);
    });
  });
}
var purgeFromHtml = function(tree) {
  const selectors = [];
  tree.walk((node) => {
    const classes = node.attrs && node.attrs.class && node.attrs.class.split(" ") || [];
    const ids = node.attrs && node.attrs.id && node.attrs.id.split(" ") || [];
    selectors.push(...classes, ...ids);
    node.tag && selectors.push(node.tag);
    return node;
  });
  return () => selectors;
};
function processStyleNodePurgeCSS(tree, styleNode, purgecssOptions, purgecss) {
  const css = extractCssFromStyleNode(styleNode);
  return runPurgecss(tree, css, purgecssOptions, purgecss).then((css2) => {
    if (css2.trim().length === 0) {
      styleNode.tag = false;
      styleNode.content = [];
      return;
    }
    styleNode.content = [css2];
  });
}
function runPurgecss(tree, css, userOptions, purgecss) {
  if (typeof userOptions !== "object") {
    userOptions = {};
  }
  const options = {
    ...userOptions,
    content: [{
      raw: tree,
      extension: "html"
    }],
    css: [{
      raw: css,
      extension: "css"
    }],
    extractors: [{
      extractor: purgeFromHtml(tree),
      extensions: ["html"]
    }]
  };
  return new purgecss.PurgeCSS().purge(options).then((result) => {
    return result[0].css;
  });
}
async function removeUnusedCss(tree, options, userOptions) {
  const promises = [];
  const html = userOptions.tool !== "purgeCSS" && tree.render(tree);
  const purgecss = await optionalImport("purgecss");
  const uncss = await optionalImport("uncss");
  tree.walk((node) => {
    if (isStyleNode(node)) {
      if (userOptions.tool === "purgeCSS") {
        if (purgecss) {
          promises.push(processStyleNodePurgeCSS(tree, node, userOptions, purgecss));
        }
      } else {
        if (uncss) {
          promises.push(processStyleNodeUnCSS(html, node, userOptions, uncss));
        }
      }
    }
    return node;
  });
  return Promise.all(promises).then(() => tree);
}
export {
  removeUnusedCss as default
};
//# sourceMappingURL=removeUnusedCss-2ZQQOQHI.js.map
