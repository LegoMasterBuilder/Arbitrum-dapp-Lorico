import {
  require_timsort
} from "./chunk-JWTS53QH.js";
import {
  attributesWithLists
} from "./chunk-JA7FWNEF.js";
import "./chunk-DLA6KCZJ.js";
import {
  __toESM
} from "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/sortAttributesWithLists.mjs
var import_timsort = __toESM(require_timsort(), 1);
var validOptions = /* @__PURE__ */ new Set(["frequency", "alphabetical"]);
var processModuleOptions = (options) => {
  if (options === true) return "alphabetical";
  return validOptions.has(options) ? options : false;
};
var AttributeTokenChain = class {
  constructor() {
    this.freqData = /* @__PURE__ */ new Map();
  }
  addFromNodeAttrsArray(attrValuesArray) {
    attrValuesArray.forEach((attrValue) => {
      if (this.freqData.has(attrValue)) {
        this.freqData.set(attrValue, this.freqData.get(attrValue) + 1);
      } else {
        this.freqData.set(attrValue, 1);
      }
    });
  }
  createSortOrder() {
    let _sortOrder = [...this.freqData.entries()];
    (0, import_timsort.sort)(_sortOrder, (a, b) => b[1] - a[1]);
    this.sortOrder = _sortOrder.map((i) => i[0]);
  }
  sortFromNodeAttrsArray(attrValuesArray) {
    const resultArray = [];
    if (!this.sortOrder) {
      this.createSortOrder();
    }
    this.sortOrder.forEach((k) => {
      if (attrValuesArray.includes(k)) {
        resultArray.push(k);
      }
    });
    return resultArray;
  }
};
function collapseAttributeWhitespace(tree, options, moduleOptions) {
  const sortType = processModuleOptions(moduleOptions);
  if (sortType === "alphabetical") {
    return sortAttributesWithListsInAlphabeticalOrder(tree);
  }
  if (sortType === "frequency") {
    return sortAttributesWithListsByFrequency(tree);
  }
  return tree;
}
function sortAttributesWithListsInAlphabeticalOrder(tree) {
  tree.walk((node) => {
    if (!node.attrs) {
      return node;
    }
    Object.keys(node.attrs).forEach((attrName) => {
      const attrNameLower = attrName.toLowerCase();
      if (!attributesWithLists.has(attrNameLower)) {
        return;
      }
      const attrValues = node.attrs[attrName].split(/\s/);
      node.attrs[attrName] = attrValues.sort((a, b) => {
        return typeof a.localeCompare === "function" ? a.localeCompare(b) : a - b;
      }).join(" ");
    });
    return node;
  });
  return tree;
}
function sortAttributesWithListsByFrequency(tree) {
  const tokenChainObj = {};
  tree.walk((node) => {
    if (!node.attrs) {
      return node;
    }
    Object.entries(node.attrs).forEach(([attrName, attrValues]) => {
      const attrNameLower = attrName.toLowerCase();
      if (!attributesWithLists.has(attrNameLower)) {
        return;
      }
      tokenChainObj[attrNameLower] = tokenChainObj[attrNameLower] || new AttributeTokenChain();
      tokenChainObj[attrNameLower].addFromNodeAttrsArray(attrValues.split(/\s/));
    });
    return node;
  });
  tree.walk((node) => {
    if (!node.attrs) {
      return node;
    }
    Object.entries(node.attrs).forEach(([attrName, attrValues]) => {
      const attrNameLower = attrName.toLowerCase();
      if (!attributesWithLists.has(attrNameLower)) {
        return;
      }
      if (tokenChainObj[attrNameLower]) {
        node.attrs[attrName] = tokenChainObj[attrNameLower].sortFromNodeAttrsArray(attrValues.split(/\s/)).join(" ");
      }
    });
    return node;
  });
}
export {
  collapseAttributeWhitespace as default
};
//# sourceMappingURL=sortAttributesWithLists-L5VWBSUY.js.map
