import {
  isComment
} from "./chunk-DLA6KCZJ.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/removeOptionalTags.mjs
var startWithWhitespacePattern = /^\s+/;
var bodyStartTagCantBeOmittedWithFirstChildTags = /* @__PURE__ */ new Set(["meta", "link", "script", "style"]);
var tbodyStartTagCantBeOmittedWithPrecededTags = /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]);
var tbodyEndTagCantBeOmittedWithFollowedTags = /* @__PURE__ */ new Set(["tbody", "tfoot"]);
function isEmptyTextNode(node) {
  if (typeof node === "string" && node.trim() === "") {
    return true;
  }
  return false;
}
function isEmptyNode(node) {
  if (!node.content) {
    return true;
  }
  if (node.content.length) {
    return !node.content.filter((n) => typeof n === "string" && isEmptyTextNode(n) ? false : true).length;
  }
  return true;
}
function getFirstChildTag(node, nonEmpty = true) {
  if (node.content && node.content.length) {
    if (nonEmpty) {
      for (const childNode of node.content) {
        if (childNode.tag) return childNode;
        if (typeof childNode === "string" && !isEmptyTextNode(childNode)) return childNode;
      }
    } else {
      return node.content[0] || null;
    }
  }
  return null;
}
function getPrevNode(tree, currentNodeIndex, nonEmpty = false) {
  if (nonEmpty) {
    for (let i = currentNodeIndex - 1; i >= 0; i--) {
      const node = tree[i];
      if (node.tag) return node;
      if (typeof node === "string" && !isEmptyTextNode(node)) return node;
    }
  } else {
    return tree[currentNodeIndex - 1] || null;
  }
  return null;
}
function getNextNode(tree, currentNodeIndex, nonEmpty = false) {
  if (nonEmpty) {
    for (let i = currentNodeIndex + 1; i < tree.length; i++) {
      const node = tree[i];
      if (node.tag) return node;
      if (typeof node === "string" && !isEmptyTextNode(node)) return node;
    }
  } else {
    return tree[currentNodeIndex + 1] || null;
  }
  return null;
}
function removeOptionalTags(tree) {
  tree.forEach((node, index) => {
    if (!node.tag) return node;
    if (node.attrs && Object.keys(node.attrs).length) return node;
    const prevNonEmptyNode = getPrevNode(tree, index, true);
    const nextNode = getNextNode(tree, index);
    const nextNonEmptyNode = getNextNode(tree, index, true);
    const firstChildNode = getFirstChildTag(node, false);
    const firstNonEmptyChildNode = getFirstChildTag(node);
    if (node.tag === "html") {
      let isHtmlStartTagCanBeOmitted = true;
      let isHtmlEndTagCanBeOmitted = true;
      if (typeof firstNonEmptyChildNode === "string" && isComment(firstNonEmptyChildNode)) {
        isHtmlStartTagCanBeOmitted = false;
      }
      if (typeof nextNonEmptyNode === "string" && isComment(nextNonEmptyNode)) {
        isHtmlEndTagCanBeOmitted = false;
      }
      if (isHtmlStartTagCanBeOmitted && isHtmlEndTagCanBeOmitted) {
        node.tag = false;
      }
    }
    if (node.tag === "head") {
      let isHeadStartTagCanBeOmitted = false;
      let isHeadEndTagCanBeOmitted = true;
      if (isEmptyNode(node) || firstNonEmptyChildNode && firstNonEmptyChildNode.tag) {
        isHeadStartTagCanBeOmitted = true;
      }
      if (nextNode && typeof nextNode === "string" && startWithWhitespacePattern.test(nextNode) || nextNonEmptyNode && typeof nextNonEmptyNode === "string" && isComment(nextNode)) {
        isHeadEndTagCanBeOmitted = false;
      }
      if (isHeadStartTagCanBeOmitted && isHeadEndTagCanBeOmitted) {
        node.tag = false;
      }
    }
    if (node.tag === "body") {
      let isBodyStartTagCanBeOmitted = true;
      let isBodyEndTagCanBeOmitted = true;
      if (typeof firstChildNode === "string" && startWithWhitespacePattern.test(firstChildNode) || typeof firstNonEmptyChildNode === "string" && isComment(firstNonEmptyChildNode)) {
        isBodyStartTagCanBeOmitted = false;
      }
      if (firstNonEmptyChildNode && firstNonEmptyChildNode.tag && bodyStartTagCantBeOmittedWithFirstChildTags.has(firstNonEmptyChildNode.tag)) {
        isBodyStartTagCanBeOmitted = false;
      }
      if (nextNode && typeof nextNode === "string" && isComment(nextNode)) {
        isBodyEndTagCanBeOmitted = false;
      }
      if (isBodyStartTagCanBeOmitted && isBodyEndTagCanBeOmitted) {
        node.tag = false;
      }
    }
    if (node.tag === "colgroup") {
      let isColgroupStartTagCanBeOmitted = false;
      let isColgroupEndTagCanBeOmitted = true;
      if (firstNonEmptyChildNode && firstNonEmptyChildNode.tag && firstNonEmptyChildNode.tag === "col") {
        isColgroupStartTagCanBeOmitted = true;
      }
      if (prevNonEmptyNode && prevNonEmptyNode.tag && prevNonEmptyNode.tag === "colgroup") {
        isColgroupStartTagCanBeOmitted = false;
      }
      if (nextNode && typeof nextNode === "string" && startWithWhitespacePattern.test(nextNode) || nextNonEmptyNode && typeof nextNonEmptyNode === "string" && isComment(nextNonEmptyNode)) {
        isColgroupEndTagCanBeOmitted = false;
      }
      if (isColgroupStartTagCanBeOmitted && isColgroupEndTagCanBeOmitted) {
        node.tag = false;
      }
    }
    if (node.tag === "tbody") {
      let isTbodyStartTagCanBeOmitted = false;
      let isTbodyEndTagCanBeOmitted = true;
      if (firstNonEmptyChildNode && firstNonEmptyChildNode.tag && firstNonEmptyChildNode.tag === "tr") {
        isTbodyStartTagCanBeOmitted = true;
      }
      if (prevNonEmptyNode && prevNonEmptyNode.tag && tbodyStartTagCantBeOmittedWithPrecededTags.has(prevNonEmptyNode.tag)) {
        isTbodyStartTagCanBeOmitted = false;
      }
      if (nextNonEmptyNode && nextNonEmptyNode.tag && tbodyEndTagCantBeOmittedWithFollowedTags.has(nextNonEmptyNode.tag)) {
        isTbodyEndTagCanBeOmitted = false;
      }
      if (isTbodyStartTagCanBeOmitted && isTbodyEndTagCanBeOmitted) {
        node.tag = false;
      }
    }
    if (node.content && node.content.length) {
      removeOptionalTags(node.content);
    }
    return node;
  });
  return tree;
}
export {
  removeOptionalTags as default
};
//# sourceMappingURL=removeOptionalTags-CRG2QUSG.js.map
