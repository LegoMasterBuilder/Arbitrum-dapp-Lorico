import {
  isComment
} from "./chunk-DLA6KCZJ.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/collapseWhitespace.mjs
var noWhitespaceCollapseElements = /* @__PURE__ */ new Set([
  "script",
  "style",
  "pre",
  "textarea"
]);
var noTrimWhitespacesArroundElements = /* @__PURE__ */ new Set([
  // non-empty tags that will maintain whitespace around them
  "a",
  "abbr",
  "acronym",
  "b",
  "bdi",
  "bdo",
  "big",
  "button",
  "cite",
  "code",
  "del",
  "dfn",
  "em",
  "font",
  "i",
  "ins",
  "kbd",
  "label",
  "mark",
  "math",
  "nobr",
  "object",
  "q",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "select",
  "small",
  "span",
  "strike",
  "strong",
  "sub",
  "sup",
  "svg",
  "textarea",
  "time",
  "tt",
  "u",
  "var",
  // self-closing tags that will maintain whitespace around them
  "comment",
  "img",
  "input",
  "wbr"
]);
var noTrimWhitespacesInsideElements = /* @__PURE__ */ new Set([
  // non-empty tags that will maintain whitespace within them
  "a",
  "abbr",
  "acronym",
  "b",
  "big",
  "del",
  "em",
  "font",
  "i",
  "ins",
  "kbd",
  "mark",
  "nobr",
  "rp",
  "s",
  "samp",
  "small",
  "span",
  "strike",
  "strong",
  "sub",
  "sup",
  "time",
  "tt",
  "u",
  "var"
]);
var startsWithWhitespacePattern = /^\s/;
var endsWithWhitespacePattern = /\s$/;
var multipleWhitespacePattern = /[\t\n\f\r ]+/g;
var NONE = "";
var SINGLE_SPACE = " ";
var validOptions = ["all", "aggressive", "conservative"];
function collapseWhitespace(tree, options, collapseType, parent) {
  collapseType = validOptions.includes(collapseType) ? collapseType : "conservative";
  tree.forEach((node, index) => {
    const prevNode = tree[index - 1];
    const nextNode = tree[index + 1];
    if (typeof node === "string") {
      const parentNodeTag = parent && parent.node && parent.node.tag;
      const isTopLevel = !parentNodeTag || parentNodeTag === "html" || parentNodeTag === "head";
      const shouldTrim = collapseType === "all" || isTopLevel || /*
       * When collapseType is set to 'aggressive', and the tag is not inside 'noTrimWhitespacesInsideElements'.
       * the first & last space inside the tag will be trimmed
       */
      collapseType === "aggressive";
      node = collapseRedundantWhitespaces(node, collapseType, shouldTrim, parent, prevNode, nextNode);
    }
    const isAllowCollapseWhitespace = !noWhitespaceCollapseElements.has(node.tag);
    if (node.content && node.content.length && isAllowCollapseWhitespace) {
      node.content = collapseWhitespace(node.content, options, collapseType, {
        node,
        prevNode,
        nextNode
      });
    }
    tree[index] = node;
  });
  return tree;
}
function collapseRedundantWhitespaces(text, collapseType, shouldTrim = false, parent, prevNode, nextNode) {
  if (!text || text.length === 0) {
    return NONE;
  }
  if (!isComment(text)) {
    text = text.replace(multipleWhitespacePattern, SINGLE_SPACE);
  }
  if (shouldTrim) {
    if (collapseType === "aggressive") {
      if (!noTrimWhitespacesInsideElements.has(parent && parent.node && parent.node.tag)) {
        if (
          // It is the first child node of the parent
          !prevNode || prevNode && prevNode.tag && !noTrimWhitespacesArroundElements.has(prevNode.tag)
        ) {
          text = text.trimStart();
        } else {
          if (
            // but previous node ends with a whitespace
            prevNode && prevNode.content && prevNode.content.length && endsWithWhitespacePattern.test(prevNode.content[prevNode.content.length - 1]) && (!nextNode || // or the next node starts with a white space
            nextNode && nextNode.content && nextNode.content.length && !startsWithWhitespacePattern.test(nextNode.content[0]))
          ) {
            text = text.trimStart();
          }
        }
        if (!nextNode || nextNode && nextNode.tag && !noTrimWhitespacesArroundElements.has(nextNode.tag)) {
          text = text.trimEnd();
        }
      } else {
        if (!prevNode && startsWithWhitespacePattern.test(text[0]) && typeof parent.prevNode === "string" && endsWithWhitespacePattern.test(parent.prevNode[parent.prevNode.length - 1])) {
          text = text.trimStart();
        }
      }
    } else {
      text = text.trim();
    }
  }
  return text;
}
export {
  collapseWhitespace as default
};
//# sourceMappingURL=collapseWhitespace-7NUXSBLK.js.map
