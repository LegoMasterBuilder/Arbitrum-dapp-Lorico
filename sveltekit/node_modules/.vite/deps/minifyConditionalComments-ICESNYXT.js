import {
  isConditionalComment
} from "./chunk-DLA6KCZJ.js";
import {
  htmlnano_default
} from "./chunk-PVCYOOBY.js";
import "./chunk-LDXG4JFK.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/minifyConditionalComments.mjs
var CONDITIONAL_COMMENT_REGEXP = /(<!--\[if\s+?[^<>[\]]+?]>)([\s\S]+?)(<!\[endif\]-->)/gm;
async function minifyConditionalComments(tree, htmlnanoOptions) {
  for (let i = 0, len = tree.length; i < len; i++) {
    const node = tree[i];
    if (typeof node === "string" && isConditionalComment(node)) {
      tree[i] = await minifycontentInsideConditionalComments(node, htmlnanoOptions);
    }
    if (node.content && node.content.length) {
      tree[i].content = await minifyConditionalComments(node.content, htmlnanoOptions);
    }
  }
  return tree;
}
async function minifycontentInsideConditionalComments(text, htmlnanoOptions) {
  let match;
  const matches = [];
  while ((match = CONDITIONAL_COMMENT_REGEXP.exec(text)) !== null) {
    matches.push([match[1], match[2], match[3]]);
  }
  if (!matches.length) {
    return Promise.resolve(text);
  }
  return Promise.all(matches.map(async (match2) => {
    const result = await htmlnano_default.process(match2[1], htmlnanoOptions, {}, {});
    let minified = result.html;
    if (match2[1].includes("<html") && minified.includes("</html>")) {
      minified = minified.replace("</html>", "");
    }
    return match2[0] + minified + match2[2];
  }));
}
export {
  minifyConditionalComments as default
};
//# sourceMappingURL=minifyConditionalComments-ICESNYXT.js.map
