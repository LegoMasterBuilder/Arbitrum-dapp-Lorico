{
  "version": 3,
  "sources": ["../../.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/minifyJs.mjs"],
  "sourcesContent": ["import { isEventHandler, optionalImport } from '../helpers.mjs';\nimport { redundantScriptTypes } from './removeRedundantAttributes.mjs';\n\n/** Minify JS with Terser */\nexport default async function minifyJs (tree, options, terserOptions) {\n    const terser = await optionalImport('terser');\n\n    if (!terser) return tree;\n\n    let promises = [];\n    tree.walk(node => {\n        const nodeAttrs = node.attrs || {};\n\n        /**\n         * Skip SRI\n         *\n         * If the input <script /> has an SRI attribute, it means that the original <script /> could be trusted,\n         * and should not be altered anymore.\n         *\n         * htmlnano is exactly an MITM that SRI is designed to protect from. If htmlnano or its dependencies get\n         * compromised and introduces malicious code, then it is up to the original SRI to protect the end user.\n         *\n         * So htmlnano will simply skip <script /> that has SRI.\n         * If developers do trust htmlnano, they should generate SRI after htmlnano modify the <script />.\n         */\n        if ('integrity' in nodeAttrs) {\n            return node;\n        }\n\n        if (node.tag && node.tag === 'script') {\n            const mimeType = nodeAttrs.type || 'text/javascript';\n            if (redundantScriptTypes.has(mimeType) || mimeType === 'module') {\n                promises.push(processScriptNode(node, terserOptions, terser));\n            }\n        }\n\n        if (node.attrs) {\n            promises = promises.concat(processNodeWithOnAttrs(node, terserOptions, terser));\n        }\n\n        return node;\n    });\n\n    return Promise.all(promises).then(() => tree);\n}\n\n\nfunction stripCdata (js) {\n    const leftStrippedJs = js.replace(/\\/\\/\\s*<!\\[CDATA\\[/, '').replace(/\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\//, '');\n    if (leftStrippedJs === js) {\n        return js;\n    }\n\n    const strippedJs = leftStrippedJs.replace(/\\/\\/\\s*\\]\\]>/, '').replace(/\\/\\*\\s*\\]\\]>\\s*\\*\\//, '');\n    return leftStrippedJs === strippedJs ? js : strippedJs;\n}\n\n\nfunction processScriptNode (scriptNode, terserOptions, terser) {\n    let js = (scriptNode.content || []).join('').trim();\n    if (!js) {\n        return scriptNode;\n    }\n\n    // Improve performance by avoiding calling stripCdata again and again\n    let isCdataWrapped = false;\n    if (js.includes('CDATA')) {\n        const strippedJs = stripCdata(js);\n        isCdataWrapped = js !== strippedJs;\n        js = strippedJs;\n    }\n\n    return terser\n        .minify(js, terserOptions)\n        .then(result => {\n            if (result.error) {\n                throw new Error(result.error);\n            }\n            if (result.code === undefined) {\n                return;\n            }\n\n            let content = result.code;\n            if (isCdataWrapped) {\n                content = '/*<![CDATA[*/' + content + '/*]]>*/';\n            }\n\n            scriptNode.content = [content];\n        });\n}\n\n\nfunction processNodeWithOnAttrs (node, terserOptions, terser) {\n    const jsWrapperStart = 'a=function(){';\n    const jsWrapperEnd = '};a();';\n\n    const promises = [];\n    for (const attrName of Object.keys(node.attrs || {})) {\n        if (!isEventHandler(attrName)) {\n            continue;\n        }\n\n        // For example onclick=\"return false\" is valid,\n        // but \"return false;\" is invalid (error: 'return' outside of function)\n        // Therefore the attribute's code should be wrapped inside function:\n        // \"function _(){return false;}\"\n        let wrappedJs = jsWrapperStart + node.attrs[attrName] + jsWrapperEnd;\n        let promise = terser\n            .minify(wrappedJs, terserOptions)\n            .then(({ code }) => {\n                let minifiedJs = code.substring(\n                    jsWrapperStart.length,\n                    code.length - jsWrapperEnd.length\n                );\n                node.attrs[attrName] = minifiedJs;\n            });\n        promises.push(promise);\n    }\n\n    return promises;\n}\n"],
  "mappings": ";;;;;;;;;;AAIA,eAAO,SAAiC,MAAM,SAAS,eAAe;AAClE,QAAM,SAAS,MAAM,eAAe,QAAQ;AAE5C,MAAI,CAAC,OAAQ,QAAO;AAEpB,MAAI,WAAW,CAAC;AAChB,OAAK,KAAK,UAAQ;AACd,UAAM,YAAY,KAAK,SAAS,CAAC;AAcjC,QAAI,eAAe,WAAW;AAC1B,aAAO;AAAA,IACX;AAEA,QAAI,KAAK,OAAO,KAAK,QAAQ,UAAU;AACnC,YAAM,WAAW,UAAU,QAAQ;AACnC,UAAI,qBAAqB,IAAI,QAAQ,KAAK,aAAa,UAAU;AAC7D,iBAAS,KAAK,kBAAkB,MAAM,eAAe,MAAM,CAAC;AAAA,MAChE;AAAA,IACJ;AAEA,QAAI,KAAK,OAAO;AACZ,iBAAW,SAAS,OAAO,uBAAuB,MAAM,eAAe,MAAM,CAAC;AAAA,IAClF;AAEA,WAAO;AAAA,EACX,CAAC;AAED,SAAO,QAAQ,IAAI,QAAQ,EAAE,KAAK,MAAM,IAAI;AAChD;AAGA,SAAS,WAAY,IAAI;AACrB,QAAM,iBAAiB,GAAG,QAAQ,sBAAsB,EAAE,EAAE,QAAQ,6BAA6B,EAAE;AACnG,MAAI,mBAAmB,IAAI;AACvB,WAAO;AAAA,EACX;AAEA,QAAM,aAAa,eAAe,QAAQ,gBAAgB,EAAE,EAAE,QAAQ,uBAAuB,EAAE;AAC/F,SAAO,mBAAmB,aAAa,KAAK;AAChD;AAGA,SAAS,kBAAmB,YAAY,eAAe,QAAQ;AAC3D,MAAI,MAAM,WAAW,WAAW,CAAC,GAAG,KAAK,EAAE,EAAE,KAAK;AAClD,MAAI,CAAC,IAAI;AACL,WAAO;AAAA,EACX;AAGA,MAAI,iBAAiB;AACrB,MAAI,GAAG,SAAS,OAAO,GAAG;AACtB,UAAM,aAAa,WAAW,EAAE;AAChC,qBAAiB,OAAO;AACxB,SAAK;AAAA,EACT;AAEA,SAAO,OACF,OAAO,IAAI,aAAa,EACxB,KAAK,YAAU;AACZ,QAAI,OAAO,OAAO;AACd,YAAM,IAAI,MAAM,OAAO,KAAK;AAAA,IAChC;AACA,QAAI,OAAO,SAAS,QAAW;AAC3B;AAAA,IACJ;AAEA,QAAI,UAAU,OAAO;AACrB,QAAI,gBAAgB;AAChB,gBAAU,kBAAkB,UAAU;AAAA,IAC1C;AAEA,eAAW,UAAU,CAAC,OAAO;AAAA,EACjC,CAAC;AACT;AAGA,SAAS,uBAAwB,MAAM,eAAe,QAAQ;AAC1D,QAAM,iBAAiB;AACvB,QAAM,eAAe;AAErB,QAAM,WAAW,CAAC;AAClB,aAAW,YAAY,OAAO,KAAK,KAAK,SAAS,CAAC,CAAC,GAAG;AAClD,QAAI,CAAC,eAAe,QAAQ,GAAG;AAC3B;AAAA,IACJ;AAMA,QAAI,YAAY,iBAAiB,KAAK,MAAM,QAAQ,IAAI;AACxD,QAAI,UAAU,OACT,OAAO,WAAW,aAAa,EAC/B,KAAK,CAAC,EAAE,KAAK,MAAM;AAChB,UAAI,aAAa,KAAK;AAAA,QAClB,eAAe;AAAA,QACf,KAAK,SAAS,aAAa;AAAA,MAC/B;AACA,WAAK,MAAM,QAAQ,IAAI;AAAA,IAC3B,CAAC;AACL,aAAS,KAAK,OAAO;AAAA,EACzB;AAEA,SAAO;AACX;",
  "names": []
}
