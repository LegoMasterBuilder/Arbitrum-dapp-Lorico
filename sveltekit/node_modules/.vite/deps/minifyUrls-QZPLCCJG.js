import {
  optionalImport
} from "./chunk-DLA6KCZJ.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/minifyUrls.mjs
var tagsHaveUriValuesForAttributes = /* @__PURE__ */ new Set([
  "a",
  "area",
  "link",
  "base",
  "object",
  "blockquote",
  "q",
  "del",
  "ins",
  "form",
  "input",
  "head",
  "audio",
  "embed",
  "iframe",
  "img",
  "script",
  "track",
  "video"
]);
var tagsHasHrefAttributes = /* @__PURE__ */ new Set([
  "a",
  "area",
  "link",
  "base"
]);
var attributesOfImgTagHasUriValues = /* @__PURE__ */ new Set([
  "src",
  "longdesc",
  "usemap"
]);
var attributesOfObjectTagHasUriValues = /* @__PURE__ */ new Set([
  "classid",
  "codebase",
  "data",
  "usemap"
]);
var tagsHasCiteAttributes = /* @__PURE__ */ new Set([
  "blockquote",
  "q",
  "ins",
  "del"
]);
var tagsHasSrcAttributes = /* @__PURE__ */ new Set([
  "audio",
  "embed",
  "iframe",
  "img",
  "input",
  "script",
  "track",
  "video",
  /**
   * https://html.spec.whatwg.org/#attr-source-src
   *
   * Although most of browsers recommend not to use "src" in <source>,
   * but technically it does comply with HTML Standard.
   */
  "source"
]);
var isUriTypeAttribute = (tag, attr) => {
  return tagsHasHrefAttributes.has(tag) && attr === "href" || tag === "img" && attributesOfImgTagHasUriValues.has(attr) || tag === "object" && attributesOfObjectTagHasUriValues.has(attr) || tagsHasCiteAttributes.has(tag) && attr === "cite" || tag === "form" && attr === "action" || tag === "input" && attr === "usemap" || tag === "head" && attr === "profile" || tag === "script" && attr === "for" || tagsHasSrcAttributes.has(tag) && attr === "src";
};
var isSrcsetAttribute = (tag, attr) => {
  return tag === "source" && attr === "srcset" || tag === "img" && attr === "srcset" || tag === "link" && attr === "imagesrcset";
};
var processModuleOptions = (options) => {
  if (typeof options === "string") return options;
  if (options instanceof URL) return options.toString();
  return false;
};
var isLinkRelCanonical = ({ tag, attrs }) => {
  if (tag !== "link") return false;
  for (const [attrName, attrValue] of Object.entries(attrs)) {
    if (attrName.toLowerCase() === "rel" && attrValue === "canonical") return true;
  }
  return false;
};
var JAVASCRIPT_URL_PROTOCOL = "javascript:";
var relateUrlInstance;
var STORED_URL_BASE;
async function minifyUrls(tree, options, moduleOptions) {
  const RelateUrl = await optionalImport("relateurl");
  const srcset = await optionalImport("srcset");
  const terser = await optionalImport("terser");
  let promises = [];
  const urlBase = processModuleOptions(moduleOptions);
  if (!urlBase) return tree;
  if (!relateUrlInstance || STORED_URL_BASE !== urlBase) {
    if (RelateUrl) {
      relateUrlInstance = new RelateUrl(urlBase);
    }
    STORED_URL_BASE = urlBase;
  }
  tree.walk((node) => {
    if (!node.attrs) return node;
    if (!node.tag) return node;
    if (!tagsHaveUriValuesForAttributes.has(node.tag)) return node;
    if (isLinkRelCanonical(node)) return node;
    for (const [attrName, attrValue] of Object.entries(node.attrs)) {
      const attrNameLower = attrName.toLowerCase();
      if (isUriTypeAttribute(node.tag, attrNameLower)) {
        if (isJavaScriptUrl(attrValue)) {
          promises.push(minifyJavaScriptUrl(node, attrName, terser));
        } else {
          if (relateUrlInstance) {
            node.attrs[attrName] = relateUrlInstance.relate(attrValue);
          }
        }
        continue;
      }
      if (isSrcsetAttribute(node.tag, attrNameLower)) {
        if (srcset) {
          try {
            const parsedSrcset = srcset.parseSrcset(attrValue, { strict: true });
            node.attrs[attrName] = srcset.stringifySrcset(parsedSrcset.map((item) => {
              if (relateUrlInstance) {
                item.url = relateUrlInstance.relate(item.url);
              }
              return item;
            }));
          } catch (e) {
          }
        }
        continue;
      }
    }
    return node;
  });
  if (promises.length > 0) return Promise.all(promises).then(() => tree);
  return Promise.resolve(tree);
}
function isJavaScriptUrl(url) {
  return typeof url === "string" && url.toLowerCase().startsWith(JAVASCRIPT_URL_PROTOCOL);
}
var jsWrapperStart = "function a(){";
var jsWrapperEnd = "}a();";
function minifyJavaScriptUrl(node, attrName, terser) {
  if (!terser) return Promise.resolve();
  let result = node.attrs[attrName];
  if (result) {
    result = jsWrapperStart + result.slice(JAVASCRIPT_URL_PROTOCOL.length) + jsWrapperEnd;
    return terser.minify(result, {}).then(({ code }) => {
      const minifiedJs = code.substring(
        jsWrapperStart.length,
        code.length - jsWrapperEnd.length
      );
      node.attrs[attrName] = JAVASCRIPT_URL_PROTOCOL + minifiedJs;
    });
  }
  return Promise.resolve();
}
export {
  minifyUrls as default
};
//# sourceMappingURL=minifyUrls-QZPLCCJG.js.map
