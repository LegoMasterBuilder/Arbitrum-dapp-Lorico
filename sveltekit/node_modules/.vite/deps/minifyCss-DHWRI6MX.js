import {
  extractCssFromStyleNode,
  isStyleNode,
  optionalImport
} from "./chunk-DLA6KCZJ.js";
import "./chunk-P3KJJCU4.js";

// node_modules/.pnpm/htmlnano@2.1.1_postcss@8.4.38_terser@5.31.1_typescript@5.4.5/node_modules/htmlnano/lib/modules/minifyCss.mjs
var postcssOptions = {
  // Prevent the following warning from being shown:
  // > Without `from` option PostCSS could generate wrong source map and will not find Browserslist config.
  // > Set it to CSS file path or to `undefined` to prevent this warning.
  from: void 0
};
async function minifyCss(tree, options, cssnanoOptions) {
  const cssnano = await optionalImport("cssnano");
  const postcss = await optionalImport("postcss");
  if (!cssnano || !postcss) {
    return tree;
  }
  let promises = [];
  tree.walk((node) => {
    if (node.attrs && "integrity" in node.attrs) {
      return node;
    }
    if (isStyleNode(node)) {
      promises.push(processStyleNode(node, cssnanoOptions, cssnano, postcss));
    } else if (node.attrs && node.attrs.style) {
      promises.push(processStyleAttr(node, cssnanoOptions, cssnano, postcss));
    }
    return node;
  });
  return Promise.all(promises).then(() => tree);
}
function processStyleNode(styleNode, cssnanoOptions, cssnano, postcss) {
  let css = extractCssFromStyleNode(styleNode);
  let isCdataWrapped = false;
  if (css.includes("CDATA")) {
    const strippedCss = stripCdata(css);
    isCdataWrapped = css !== strippedCss;
    css = strippedCss;
  }
  return postcss([cssnano(cssnanoOptions)]).process(css, postcssOptions).then((result) => {
    if (isCdataWrapped) {
      return styleNode.content = ["<![CDATA[" + result + "]]>"];
    }
    return styleNode.content = [result.css];
  });
}
function processStyleAttr(node, cssnanoOptions, cssnano, postcss) {
  const wrapperStart = "a{";
  const wrapperEnd = "}";
  const wrappedStyle = wrapperStart + (node.attrs.style || "") + wrapperEnd;
  return postcss([cssnano(cssnanoOptions)]).process(wrappedStyle, postcssOptions).then((result) => {
    const minifiedCss = result.css;
    node.attrs.style = minifiedCss.substring(
      wrapperStart.length,
      minifiedCss.length - wrapperEnd.length
    );
  });
}
function stripCdata(css) {
  const leftStrippedCss = css.replace("<![CDATA[", "");
  if (leftStrippedCss === css) {
    return css;
  }
  const strippedCss = leftStrippedCss.replace("]]>", "");
  return leftStrippedCss === strippedCss ? css : strippedCss;
}
export {
  minifyCss as default
};
//# sourceMappingURL=minifyCss-DHWRI6MX.js.map
